[
  {
    "objectID": "fragmentation.html",
    "href": "fragmentation.html",
    "title": "Fragmentation",
    "section": "",
    "text": "source\n\ncount_dummies\n\n count_dummies (mol:rdkit.Chem.rdchem.Mol)\n\nFunction to count dummy atoms.\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nMol\ninput molecule\n\n\nReturns\nint\ncount of dummy atoms\n\n\n\n\nfrag = '*c1c(C)cccc1C'\nprint(count_dummies(mol_from_smiles(frag)))\n\n1\n\n\n\nfrag = '*NC(*)C'\nprint(count_dummies(mol_from_smiles(frag)))\n\n2\n\n\nUnit Tests\n\ntest_eq(count_dummies(mol_from_smiles('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1')),0)\ntest_eq(count_dummies(mol_from_smiles('*c1c(C)cccc1C')),1)\ntest_eq(count_dummies(mol_from_smiles('*NC(*)C')),2)\n\n\nsource\n\n\nget_size\n\n get_size (frag:rdkit.Chem.rdchem.Mol)\n\nFunction to count real atoms.\n\n\n\n\nType\nDetails\n\n\n\n\nfrag\nMol\ninput fragment\n\n\nReturns\nint\ncount of real atoms\n\n\n\n\nfrag = '*c1c(C)cccc1C'\nprint(get_size(mol_from_smiles(frag)))\n\n8\n\n\n\nfrag = '*NC(*)C'\nprint(get_size(mol_from_smiles(frag)))\n\n3\n\n\n\nsmi = 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nprint(get_size(mol_from_smiles(smi)))\n\n27\n\n\nUnit Tests\n\ntest_eq(get_size(mol_from_smiles('*c1c(C)cccc1C')), 8)\ntest_eq(get_size(mol_from_smiles('*NC(*)C')), 3)\ntest_eq(get_size(mol_from_smiles('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1')), 27)\n\n\nsource\n\n\nreplace_last\n\n replace_last (s:str, old:str, new:str)\n\nFunction to replace the last occuring dummy label with a fragment.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ns\nstr\nthe string (fragment) to which the dummy label * is to be replaced with another fragment\n\n\nold\nstr\nthe string from the fragment s to be replaced\n\n\nnew\nstr\nthe string to replace the ‘old’ string in the fragment s\n\n\nReturns\nstr\nthe original string s with the replacement\n\n\n\n\ns = 'N(*)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nold = '*'\nnew = 'c1c(C)cccc1C'\nprint(replace_last(s, old, new))\n\nN(c1c(C)cccc1C)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1\n\n\n\ns = 'C(*)(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nold = '*'\nnew = 'N*'\nprint(replace_last(s, old, new))\n\nC(N*)(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1\n\n\nUnit Tests\n\ntest_eq(replace_last('N(*)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1', '*', 'c1c(C)cccc1C'),\n        'N(c1c(C)cccc1C)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1')\ntest_eq(replace_last('C(*)(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1', '*', 'N*'),\n        'C(N*)(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1')\n\n\nsource\n\n\ncheck_reconstruction\n\n check_reconstruction (frags:list[str], frag_1:str, frag_2:str, orig_smi)\n\nFunction to test whether the original molecule has been reconstructed.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfrags\nlist\nlist of fragments in SMILES format\n\n\nfrag_1\nstr\nhead/tail fragment in SMILES format\n\n\nfrag_2\nstr\nhead/tail fragment in SMILES format\n\n\norig_smi\n\noriginal molecule in SMILES format\n\n\nReturns\nbool\nwhether the original molecule was reconstructed\n\n\n\n\nfrags = []\nfrag_1 = '*CCC'\nfrag_2 = 'N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\norig_smi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nprint(check_reconstruction(frags, frag_1, frag_2, orig_smi))\n\nTrue\n\n\n\nfrags = ['*c1c(C)cccc1C', '*N*', '*CC(*)=O']\nfrag_1 = '*C1CC[NH+](*)CC1'\nfrag_2 = 'O(*)Cc1ccc(F)cc1'\norig_smi = 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nprint(check_reconstruction(frags, frag_1, frag_2, orig_smi))\n\nTrue\n\n\nUnit Tests\n\ntest_eq(check_reconstruction([], '*CCC', 'N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'), True)\ntest_eq(check_reconstruction(['*c1c(C)cccc1C', '*N*', '*CC(*)=O'], '*C1CC[NH+](*)CC1', 'O(*)Cc1ccc(F)cc1', 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'), True)\ntest_fail(check_reconstruction([], '*CCC', 'N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', 'C(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'))\n\n\nsource\n\n\ncheck_bond_no\n\n check_bond_no (bonds:list, frags:list, frag_list_len:int, smi:str,\n                verbose:int=0)\n\nThis function checks if the molecule has less bonds than the limit of BRIC bonds.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nbonds\nlist\n\nthe list of BRIC bonds locations\n\n\nfrags\nlist\n\nthe list of fragments\n\n\nfrag_list_len\nint\n\nthe length of the fragment list\n\n\nsmi\nstr\n\nthe smiles string of the molecule\n\n\nverbose\nint\n0\nprint fragmentation process, set verbose to 1\n\n\nReturns\ntuple\n\na tuple containing the fragment list and a boolean value to indicate whether fragmentation is complete\n\n\n\n\nbonds = []\nfrags = ['*c1c(C)cccc1C', '*N*', '*CC(*)=O', '*C1CC[NH+](*)CC1', '*O*', '*C*', 'c1(*)ccc(F)cc1']\nfrags_list_len = 0\nsmi = 'c1(*)ccc(F)cc1'\nprint(check_bond_no(bonds, frags, frags_list_len, smi))\n\n(['*c1c(C)cccc1C', '*N*', '*CC(*)=O', '*C1CC[NH+](*)CC1', '*O*', '*C*', 'c1(*)ccc(F)cc1', 'c1(*)ccc(F)cc1'], True)\n\n\n\nbonds = [((9, 8), ('1', '5')), ((16, 17), ('3', '4')), ((16, 15), ('3', '15')), ((11, 12), ('4', '5')), ((8, 7), ('5', '16')), ((17, 18), ('8', '16'))]\nfrags = []\nfrags_list_len = 0\nsmi = 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nprint(check_bond_no(bonds, frags, frags_list_len, smi))\n\n([], False)\n\n\nUnit Tests\n\ntest_eq(check_bond_no([], ['*c1c(C)cccc1C', '*N*', '*CC(*)=O', '*C1CC[NH+](*)CC1', '*O*', '*C*', 'c1(*)ccc(F)cc1'], 0, 'c1(*)ccc(F)cc1'),(['*c1c(C)cccc1C', '*N*', '*CC(*)=O', '*C1CC[NH+](*)CC1', '*O*', '*C*', 'c1(*)ccc(F)cc1', 'c1(*)ccc(F)cc1'], True))\ntest_eq(check_bond_no([((9, 8), ('1', '5')), ((16, 17), ('3', '4')), ((16, 15), ('3', '15')), ((11, 12), ('4', '5')), ((8, 7), ('5', '16')), ((17, 18), ('8', '16'))], [], 0, 'c1(*)ccc(F)cc1'),([], False))\n\n\nsource\n\n\nfragment_recursive\n\n fragment_recursive (smi_orig:str, smi:str, frags:list, counter:int,\n                     frag_list_len:int, min_length:int=0, verbose:int=0)\n\nThis recursive function fragments a molecule using the DEFRAGMO fragmentation method.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmi_orig\nstr\n\nthe original smiles string of the molecule\n\n\nsmi\nstr\n\nthe smiles string of the molecule\n\n\nfrags\nlist\n\nthe list of fragments\n\n\ncounter\nint\n\nthe counter for the recursion\n\n\nfrag_list_len\nint\n\nthe length of the fragment list\n\n\nmin_length\nint\n0\nthe minimum number of atoms in a fragment\n\n\nverbose\nint\n0\nprint fragmentation process, set verbose to 1\n\n\nReturns\nlist\n\nthe list of fragments\n\n\n\n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nfrags = []\nprint(fragment_recursive(smi, smi, frags, 0, 0, min_length=0, verbose=1))\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *N(*)*\nRecurse tail:  C(*)(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(*)=O\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n['*CCC', '*CCc1cccc(-c2ccccc2)c1', '*N(*)*', '*C(*)=O', '*NC1C(N)C=C(C(=O)O)OC1*', 'C(*)(C)=O']\n\n\n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nfrags = []\nprint(fragment_recursive(smi, smi, frags, 0, 0, min_length=3, verbose=1))\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(=O)N(*)*\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n['*CCC', '*CCc1cccc(-c2ccccc2)c1', '*C(=O)N(*)*', '*NC1C(N)C=C(C(=O)O)OC1*', 'C(*)(C)=O']\n\n\n\nsmi = 'COc1ccc(C(=O)Nc2cc(C(C)C)c(O)c(S(=O)(=O)c3ccc(OC)cc3)c2C)cc1'\nfrags = []\nprint(fragment_recursive(smi, smi, frags, 0, 0, min_length=0, verbose=1))\n\nHead fragment:  *OC\nRecurse tail:  c1(*)ccc(C(=O)Nc2cc(C(C)C)c(O)c(S(=O)(=O)c3ccc(OC)cc3)c2C)cc1\nHead fragment:  *c1ccc(*)cc1\nRecurse tail:  C(*)(=O)Nc1cc(C(C)C)c(O)c(S(=O)(=O)c2ccc(OC)cc2)c1C\nHead fragment:  *C(*)=O\nRecurse tail:  N(*)c1cc(C(C)C)c(O)c(S(=O)(=O)c2ccc(OC)cc2)c1C\nHead fragment:  *N*\nRecurse tail:  c1(*)cc(C(C)C)c(O)c(S(=O)(=O)c2ccc(OC)cc2)c1C\nTail:  *C(C)C\nRecurse Head:  c1(*)cc(*)c(O)c(S(=O)(=O)c2ccc(OC)cc2)c1C\nHead fragment:  *c1ccc(S(=O)(=O)c2c(C)c(*)cc(*)c2O)cc1\nRecurse tail:  O(*)C\nFinal Fragment:  O(*)C\n['*OC', '*c1ccc(*)cc1', '*C(*)=O', '*N*', '*C(C)C', '*c1ccc(S(=O)(=O)c2c(C)c(*)cc(*)c2O)cc1', 'O(*)C']\n\n\nUnit Tests\n\ntest_eq(fragment_recursive('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', [], 0, 0, min_length=0), ['*CCC', '*CCc1cccc(-c2ccccc2)c1', '*N(*)*', '*C(*)=O', '*NC1C(N)C=C(C(=O)O)OC1*', 'C(*)(C)=O'])\ntest_eq(fragment_recursive('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', [], 0, 0, min_length=3), ['*CCC', '*CCc1cccc(-c2ccccc2)c1', '*C(=O)N(*)*', '*NC1C(N)C=C(C(=O)O)OC1*', 'C(*)(C)=O'])\ntest_eq(fragment_recursive('COc1ccc(C(=O)Nc2cc(C(C)C)c(O)c(S(=O)(=O)c3ccc(OC)cc3)c2C)cc1', 'COc1ccc(C(=O)Nc2cc(C(C)C)c(O)c(S(=O)(=O)c3ccc(OC)cc3)c2C)cc1', [], 0, 0, min_length=0), ['*OC', '*c1ccc(*)cc1', '*C(*)=O', '*N*', '*C(C)C', '*c1ccc(S(=O)(=O)c2c(C)c(*)cc(*)c2O)cc1', 'O(*)C'])\n\n\nsource\n\n\nbreak_into_fragments_defragmo\n\n break_into_fragments_defragmo (smi:str, min_length:int=0, verbose:int=0)\n\nThis function breaks a molecule into fragments using the DEFRAGMO fragmentation method.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmi\nstr\n\nthe smiles string of the molecule\n\n\nmin_length\nint\n0\nthe minimum number of atoms in a fragment\n\n\nverbose\nint\n0\nprint fragmentation process, set verbose to 1\n\n\nReturns\ntuple\n\na tuple containing the original smiles, the fragmented smiles, and the number of fragments\n\n\n\n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nbreak_into_fragments_defragmo(smi, min_length=0, verbose=1)\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *N(*)*\nRecurse tail:  C(*)(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(*)=O\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n\n\n('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O',\n '*CCC *CCc1cccc(-c2ccccc2)c1 *N(*)* *C(*)=O *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O',\n 6)\n\n\n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nbreak_into_fragments_defragmo(smi, min_length=3, verbose=1)\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(=O)N(*)*\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n\n\n('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O',\n '*CCC *CCc1cccc(-c2ccccc2)c1 *C(=O)N(*)* *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O',\n 5)\n\n\n\nsmi = 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nbreak_into_fragments_defragmo(smi, min_length=0, verbose=1)\n\nHead fragment:  *c1c(C)cccc1C\nRecurse tail:  N(*)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1\nHead fragment:  *N*\nRecurse tail:  C(*)(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1\nHead fragment:  *CC(*)=O\nRecurse tail:  [NH+]1(*)CCC(OCc2ccc(F)cc2)CC1\nHead fragment:  *C1CC[NH+](*)CC1\nRecurse tail:  O(*)Cc1ccc(F)cc1\nHead fragment:  *O*\nRecurse tail:  C(*)c1ccc(F)cc1\nHead fragment:  *C*\nRecurse tail:  c1(*)ccc(F)cc1\nFinal Fragment:  c1(*)ccc(F)cc1\n\n\n('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1',\n '*c1c(C)cccc1C *N* *CC(*)=O *C1CC[NH+](*)CC1 *O* *C* c1(*)ccc(F)cc1',\n 7)\n\n\n\nsmi = 'Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'\nbreak_into_fragments_defragmo(smi, min_length=3, verbose=1)\n\nHead fragment:  *c1c(C)cccc1C\nRecurse tail:  N(*)C(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1\nHead fragment:  *CC(=O)N*\nRecurse tail:  [NH+]1(*)CCC(OCc2ccc(F)cc2)CC1\nHead fragment:  *C1CC[NH+](*)CC1\nRecurse tail:  O(*)Cc1ccc(F)cc1\nFinal Fragment:  O(*)Cc1ccc(F)cc1\n\n\n('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1',\n '*c1c(C)cccc1C *CC(=O)N* *C1CC[NH+](*)CC1 O(*)Cc1ccc(F)cc1',\n 4)\n\n\nUnit Tests\n\ntest_eq(break_into_fragments_defragmo('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'), ('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', '*CCC *CCc1cccc(-c2ccccc2)c1 *N(*)* *C(*)=O *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O', 6))\ntest_eq(break_into_fragments_defragmo('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', min_length=3), ('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', '*CCC *CCc1cccc(-c2ccccc2)c1 *C(=O)N(*)* *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O', 5))\ntest_eq(break_into_fragments_defragmo('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1'), ('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1', '*c1c(C)cccc1C *N* *CC(*)=O *C1CC[NH+](*)CC1 *O* *C* c1(*)ccc(F)cc1', 7))\ntest_eq(break_into_fragments_defragmo('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1', min_length=3), ('Cc1cccc(C)c1NC(=O)C[NH+]1CCC(OCc2ccc(F)cc2)CC1', '*c1c(C)cccc1C *CC(=O)N* *C1CC[NH+](*)CC1 O(*)Cc1ccc(F)cc1', 4))",
    "crumbs": [
      "Fragmentation"
    ]
  },
  {
    "objectID": "utilities.html",
    "href": "utilities.html",
    "title": "Utilities",
    "section": "",
    "text": "source\n\ncanonicalize\n\n canonicalize (smi:str, clear_stereo:bool=False)\n\nThis function returns the canonicalised smiles representation and has the option to clear stereochemistry\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmi\nstr\n\ninput molecule\n\n\nclear_stereo\nbool\nFalse\nif True, clears stereochemistry of the molecule (remove the @@)\n\n\nReturns\nstr\n\ncanonicalised molecule\n\n\n\n\ncanonicalize('C(CC)N(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\n\n'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\nCanonicalizing an already canonicalized molecule\n\ncanonicalize('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\n\n'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\nUnit Tests\n\ntest_eq(canonicalize('C(CC)N(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'), canonicalize('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'))\ntest_fail(canonicalize('CN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'), 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\n\n\nsource\n\n\nmol_from_smiles\n\n mol_from_smiles (smi:str)\n\nThis function converts a SMILES string to a molecule.\n\n\n\n\nType\nDetails\n\n\n\n\nsmi\nstr\nInput molecule in SMILES.\n\n\nReturns\nMol\nOutput molecule.\n\n\n\n\nmol_from_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\n\n\n\n\n\n\n\n\n\nmol_from_smiles('CSc1cccc2sc(N3CCN(C(=O)c4ccn(C(C)C)n4)CC3)nc12')\n\n\n\n\n\n\n\n\n\nsource\n\n\nmol_to_smiles\n\n mol_to_smiles (mol:rdkit.Chem.rdchem.Mol, rootedAtAtom:int=None)\n\nThis function converts a molecule to a SMILES string.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmol\nMol\n\nmolecule to convert into SMILES string\n\n\nrootedAtAtom\nint\nNone\nSMILES string rooted at the input atom\n\n\nReturns\nstr\n\ncanonicalized SMILES string\n\n\n\n\nmol = mol_from_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\nmol\n\n\n\n\n\n\n\n\n\nmol_to_smiles(mol)\n\n'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\n\nmol_to_smiles(mol, rootedAtAtom=3)\n\n'N(CCC)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\nUnit Tests\n\nmol = mol_from_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\nmol_2 = mol_from_smiles('C(CC)N(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\ntest_eq(mol_to_smiles(mol), 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\ntest_eq(mol_to_smiles(mol, rootedAtAtom=3), 'N(CCC)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\ntest_eq(mol_to_smiles(mol), mol_to_smiles(mol_2))\n\n\nsource\n\n\nroot_smiles\n\n root_smiles (smi:str, rootedAtAtom:int)\n\nRoot molecule in smiles format at a defined atom\n\n\n\n\nType\nDetails\n\n\n\n\nsmi\nstr\nInput molecule in SMILES\n\n\nrootedAtAtom\nint\nSMILES string rooted at the input atom\n\n\nReturns\nstr\n\n\n\n\n\nroot_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', rootedAtAtom=3)\n\n'N(CCC)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\n\nroot_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', rootedAtAtom=0)\n\n'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\n\n\nUnit Tests\n\ntest_eq(root_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', rootedAtAtom=0), 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')\ntest_eq(root_smiles('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O', rootedAtAtom=3), 'N(CCC)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O')",
    "crumbs": [
      "Utilities"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "breadth-first-fragmentation",
    "section": "",
    "text": "Install latest from the GitHub repository:\n$ pip install git+https://github.com/panukorn17/breadth-first-fragmentation.git\nor from conda\n$ conda install ptaleo17::breadth-first-fragmentation\nor from pypi\n$ pip install breadth_first_fragmentation\n\n\n\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "breadth-first-fragmentation"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "breadth-first-fragmentation",
    "section": "",
    "text": "Install latest from the GitHub repository:\n$ pip install git+https://github.com/panukorn17/breadth-first-fragmentation.git\nor from conda\n$ conda install ptaleo17::breadth-first-fragmentation\nor from pypi\n$ pip install breadth_first_fragmentation\n\n\n\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "breadth-first-fragmentation"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "breadth-first-fragmentation",
    "section": "How to use",
    "text": "How to use\n\nfrom breadth_first_fragmentation.fragmentation import break_into_fragments_defragmo\n\n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nbreak_into_fragments_defragmo(smi, min_length=0, verbose=1)\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *N(*)*\nRecurse tail:  C(*)(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(*)=O\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n\n\n('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O',\n '*CCC *CCc1cccc(-c2ccccc2)c1 *N(*)* *C(*)=O *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O',\n 6)\n\n\nVisual representation of the breadth-first-fragmentation algorithm:  \n\nsmi = 'CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O'\nbreak_into_fragments_defragmo(smi, min_length=3, verbose=1)\n\nHead fragment:  *CCC\nRecurse tail:  N(*)(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nTail:  *CCc1cccc(-c2ccccc2)c1\nRecurse Head:  N(*)(*)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *C(=O)N(*)*\nRecurse tail:  C1(*)OC(C(=O)O)=CC(N)C1NC(C)=O\nHead fragment:  *NC1C(N)C=C(C(=O)O)OC1*\nRecurse tail:  C(*)(C)=O\nFinal Fragment:  C(*)(C)=O\n\n\n('CCCN(CCc1cccc(-c2ccccc2)c1)C(=O)C1OC(C(=O)O)=CC(N)C1NC(C)=O',\n '*CCC *CCc1cccc(-c2ccccc2)c1 *C(=O)N(*)* *NC1C(N)C=C(C(=O)O)OC1* C(*)(C)=O',\n 5)",
    "crumbs": [
      "breadth-first-fragmentation"
    ]
  }
]